#!/bin/bash

#changes : the 2 freedesktop standards, config for ddmrc, share for plugins, exaile plugin, 2 ways to name selection so it can be used with user-dirs

# mail proposal 3 met daarin subdirs, environment variable die zegt of we music collection of selection usen
#practical uses
# media players keep track of ratings, the ratings apply to the same song in both directories
# edit a id3 tag in media players -> apply it on other file in collection when you return home (not really task of player though)
# media player known what music you like, it can maintain the selection (or we can use other tools like rsync, but the app must provide us the list based on app-specific lingo like ratings/last played etc)


# ddm v0.4b
# Written by Dieter Plaetinck
# http://dieter.plaetinck.be

# This code is licensed under GPL v3. See http://www.gnu.org/licenses/gpl-3.0.txt
#TODO: ignore variable that will always be used for ignoring by cp/rsync/svn/..
#TODO: be compatible with xdg userdirectories (may work already, convert ~ and see if it still works) http://www.freedesktop.org/wiki/Software/xdg-user-dirs
#NOTE: how useful is the 'direct' datatype? do we need to do anything?
#NOTE: a cache datatype? cache maintained by other program.. not needed in ddm i think
#NOTE: need to think about if it would be useful to have datasets that are multiple dataset types for different repos

# basedir spec notes
# If, when attempting to write a file, the destination dir not exist try to create as 0700. If the exists dont change perms
# this means we should bail out and show error if write fails
 
# When we cannot open/read a file we need, then the processing of the file should be skipped.
#If due to this a required file could not be found at all, the application may chose to present an error message to the user. 


 
 #
 # SOME MISC FUNCTIONS
 #


usage()
{
cat << EOF
usage: `basename $0` -a <action> [more options]
       `basename $0` -h

OPTIONS:
   -a <action>         Action         $ACTION_HELPSTRING
   -d <dataset>        Dataset        $DATASET_HELPSTRING
   -t <dataset-type>   Dataset type   $DATASET_TYPE_HELPSTRING
   -r <repo-type>      Repo type      $REPO_TYPE_HELPSTRING
   -m <message>        Message        $MESSAGE_HELPSTRING
   -v                  Verbose
   -h                  Show help      (this message)
EOF
}

ask_user ()
{
	# $1 : question to ask
	# $2 : 1 for yes/no question, just check if  $user_response='y' afterwards
	
	if [ -n "$1" ]
	then
		if [ "$2" == '1' ]
		then
			echo "$1 (y/n)"
		else
			echo "$1"
		fi
	fi
		
	read user_response
	
	if [ "$2" == '1' ]
	then
		if [ "$user_response" == 'Y' ]
		then
			user_response='y'
		fi
	fi
}

echo_verbose ()
{
	if [ -n "$VERBOSE" ]
	then
		#TODO: emits a newline too many when there is a newline at the end of "$@" such as is the case when echo_verbose_buffer is echo'd. to be fixed someday
		echo -e "$@"
	fi
}

echo_debug ()
{
	if [ "$DEBUG" == "1" ]
	then
		echo "DEBUG: $@"
	fi
}

echo_die ()
{
	echo "$@" >&2
	exit 2
}

check_is_in()
{
	test=${1:-unknown}
	allowed=${2:-unknown}
	type=${3:-unknown}
	
	found=0
	
	for all in $allowed
	do
		if [ $all == $test ]
		then
			found=1
		fi
	done
	
	if [ $found -eq 0 ]
	then
		echo_die "$test is not an allowed/known $type (allowed: $allowed)"
	fi
}

check_writable_dir ()
{
 #optional arg2 : type of dir (str)
	if [ -n "$1" ]
	then
		path="$1"
	else
		path=`pwd`
	fi
	
	if [ ! -d "$path" ]
	then
		echo_die "$2 $path does not exist or is not a directory"
	elif [ ! -r "$path" ]
	then
		echo_die "$2 $path is an existing directory, but is not readable"
	elif [ ! -x "$path" ] # not sure if this is really needed...
	then
		echo_die "$2 $path is a readable directory, but not executable"
	fi
}

check_remote_path ()
{
	path=$1
	repotype=$2
	
	if [ "$repotype" == 'svn' ]
	then
		if [ "$IGNORE_DATASET_REMOTE_SVN" -eq 0 ]
		then
			output=`svn info $path 2>&1`
			if [ $? -gt 0 ]
			then
				echo "Something appears to be wrong with the $repotype repo $path :"
				echo_die "$output"
			fi
		fi
	elif [ "$repotype" == 'vfs' ]
	then
		check_writable_dir "$path" "$repotype repo" 
	fi
}

check_local_path ()
{
	path=$1
	repotype=$2
	
	if [ "$repotype" == 'svn' ]
	then
		output=`svn info $path 2>&1`
		if [ $? -gt 0 ]
		then
			echo "Something appears to be wrong with the $repotype dataset $path :"
			echo_die "$output"
		fi

		if [ "$IGNORE_DATASET_REMOTE_SVN" -eq 0 ]
		then
			remote=`echo "$output" | grep 'URL: ' | awk '{print $2}'`
			if [ "$remote" != "$DATASET_REMOTE" ]
			then
				echo "Mismatch between remote svn paths:"
				echo ".ddm : $DATASET_REMOTE"
				echo "local svn info : $remote"
			fi
		fi
	elif [ "$repotype" == 'vfs' ]
	then
		check_writable_dir "$path" "$repotype dataset"
	fi
}


set_dataset_info()
{
	# here we set all the variables, based on what DATASET_DIR_NAME_REL (given by user) & PWD are
	# DATASET_LOCAL=''      # full path to dataset locally (including type suffix if any)
	# DATASET_REMOTE=''     # full path to dataset remotely (or locally if network mount)
	# DATASET_PATH=''       # just the path (until parent directory of dataset) ( aka dirname )
	# DATASET_DIR_NAME_REL  # identifier to dataset, taken against pwd ( could be '.','..', nothing at all, dirname, full path, ..) 
	# DATASET_DIR_NAME=''   # like $DATASET_LOCAL but no path ( aka basename) 
	# DATASET_NAME=''       # like $DATASET_DIR_NAME but no type suffix
	# DATASET_TYPE=''       # buffer,copy,extensions etc

	if [ -z "$DATASET_DIR_NAME_REL" ] || [ "$DATASET_DIR_NAME_REL" == '.' ]
	then
		DATASET_LOCAL=$PWD
	elif [ "$DATASET_DIR_NAME_REL" == '..' ]
	then
		DATASET_LOCAL=`echo $PWD | xargs dirname`
	else
		#remove trailing /, if any
		DATASET_DIR_NAME_REL=`echo $DATASET_DIR_NAME_REL | sed 's#/$##'`
	
		#prepend path, if needed
		if [ `echo $DATASET_DIR_NAME_REL | grep '/' | wc -l` -eq 0 ]
		then
			if [ $PWD != '/' ]
			then
				DATASET_LOCAL="$PWD/$DATASET_DIR_NAME_REL"
			else
				DATASET_LOCAL="/$DATASET_DIR_NAME_REL"
			fi
		fi
	fi

	DATASET_DIR_NAME=`echo $DATASET_LOCAL    | xargs basename`
	DATASET_PATH=`    echo $DATASET_LOCAL    | xargs dirname`
	DATASET_NAME=`    echo $DATASET_DIR_NAME | sed 's/-[^-]*$//'`
	[ $ACTION != checkout ] && DATASET_TYPE=`    echo $DATASET_DIR_NAME | sed 's/.*-//'`
	[ $ACTION != checkout ] && [ "$DATASET_TYPE" == "$DATASET_DIR_NAME" ] && DATASET_TYPE=$DEFAULT_DATASET_TYPE
	[ "$REPO_TYPE" == 'svn' ] && DATASET_REMOTE=`echo $SVN_BASE | sed 's#/$##'`"/${SVN_PREFIX}${DATASET_NAME}${SVN_SUFFIX}"
	[ "$REPO_TYPE" == 'vfs' ] && DATASET_REMOTE=`echo $VFS_BASE | sed 's#/$##'`"/${VFS_PREFIX}${DATASET_NAME}${VFS_SUFFIX}"
}


 #
 # WORKER HELPER FUNCTIONS. TO BE USED BY WORKER FUNCTIONS
 #
 
# delete files from dataset
deletefiles ()
{
	deletelist="$1"
	deletelistsize=`grep -cv '^$' <<< "$deletelist"`
	echo_debug "deletelist (size : $deletelistsize) : $deletelist"

	echo_verbose "Deleting old files ... ($deletelistsize items)."
	IFS=$'\n'
	for file in $deletelist
	do
		file=`echo $file | sed 's/ $//'`
		if [ "$file" != '..' ] && [ "$file" != '.' ]
		then
                        file=`echo $file | xargs echo` #remove escape characters.. dont know if this is the best way
			file=`basename $file`
                        if [ `pwd` != "$DATASET_LOCAL" ]
                        then
                        	file="$DATASET_LOCAL/$file"
                        fi
                        
			echo_verbose -n " * $file... "

                        if [ -f "$file" ]
                        then
                                echo_verbose -n "found . removing... "
                                rm "$file"
				if [ $? -eq 0 ]
				then
					echo_verbose "success"
				else
					echo_verbose "failed"
                        	fi
                        else
                                echo_verbose "not found"
                        fi
                fi
	done
}	

keepfiles ()
{
	keeplist="$1"
	keeplistsize=`grep -cv '^$' <<< "$keeplist"`
	echo_debug "keeplist (size : $keeplistsize) : $keeplist"
	
	echo_verbose "Keeping these files... ($keeplistsize items)."
        IFS=$'\n'
        for file in $keeplist
        do
        	file=`echo "$file" | xargs echo` # -0 fixes quotes but keeps escapes :(
        	file=`basename $file`
		if [ `pwd` != "$DATASET_LOCAL" ]
		then
			file="$DATASET_LOCAL/$file"
		fi

        	echo_verbose " * $file"
        done
}

getfiles () #copy files from repo into dataset
{
	getlist="$1"
	getlistsize=`grep -cv '^$' <<< "$getlist"`
	echo_debug "getlist (size :$getlistsize) : $getlist"
	
	echo_verbose "Copying new files  ... ($getlistsize items)."
	IFS=$'\n'
	for file in $getlist
	do
		file_displ=$file
		if [ `pwd` != "$DATASET_LOCAL" ]
		then
			file_displ="$DATASET_LOCAL/$file_displ"
		fi

		echo_verbose -n " * $file_displ... "
		#cp "$DATASET_REMOTE/$file" "$DATASET_LOCAL/"
		rsync -avuq --exclude='**.ddm' "$DATASET_REMOTE/$file" "$DATASET_LOCAL/"
		if [ $? -eq 0 ]
		then
			echo_verbose "success"
		else
			echo_verbose "failed"
		fi
	done
		       
}


 #
 # WORKER FUNCTIONS TO BE USED BY THE CALLBACKS
 #
 
no_action ()
{
	echo "No action taken.  This is either not implemented yet or just wouldn't make much sense."
	echo "You can 1) implement what you want in $DATASET_LOCAL/.ddm"
	echo "        2) file a feature request if this seems reasonable (or send a patch)"
	if [ -n "$1" ]
	then
		echo "Note from the author: $1"
	fi
}

# this is a useful function for selection datasets: upon execution new files are added and old ones purged ( ordered alphabetically)
# grepstring is everything (but the space) that comes in front of the filepath/names ( eg 'mplayer <args>')
slidewindow ()
{
	if [ -z "$1" ]
	then
		echo_die "Specify a string to grep on as first argument to slidewindow function"
	fi
	
	GREPSTRING=$1
	GET_NEW=${2:-'10'}
	KEEP_OLD=${3:-'0'}
	SORT=${4:-'sort'}

	echo_debug "GREPSTRING: $GREPSTRING"
	echo_debug "GET_NEW: $GET_NEW"
	echo_debug "KEEPOLD: $KEEP_OLD"
	echo_debug "DATASET_DIR_NAME: $DATASET_DIR_NAME"
	echo_debug "DATASET_REMOTE: $DATASET_REMOTE"
	echo_debug "SORT: $SORT"
	
	history -a #TODO:this doesnt work ? does work when executed from terminal o_O

	currentlist=`ls -1 "$DATASET_LOCAL"` #not really used except when no stuff in history found
	currentlistsize=`ls -1 "$DATASET_LOCAL" | wc -l`
	
	usedlist=`grep "$GREPSTRING" ~/.bash_history | grep "$DATASET_DIR_NAME" | grep -v '*' | grep -v '?' | grep -v grep | uniq`
	usedlist="${usedlist//$GREPSTRING /}"
	
	echo_debug "usedlist : $usedlist"
	
	if [ -z "$usedlist" ]
	then
		echo_verbose "Could not find any matching entries in your history.  I will only add stuff (maybe), and delete nothing"
		deletelist=''
		keeplist=`ls -1 "$DATASET_LOCAL"`
		last=''
		if [ "$GET_NEW" -gt $currentlistsize ]
		then
			# we can add some files
			if [ "$currentlistsize" > 1 ]
			then
				todo=$(($GET_NEW - $currentlistsize))
				echo_verbose "Files in dataset: $currentlistsize, wanted new files : $GET_NEW. I will fetch $todo new files."
				last=`echo "$currentlist" | $sort | tail -n 1`
				if [ -n "$last" ] 
				then	
					tmplist=`ls -1 "$DATASET_REMOTE" | $SORT | grep "$last" -A $GET_NEW`
					if [ $? -gt 0 ]
					then
						echo_die "Could not find last known element ( from dataset ) $last in repository $DATASET_REMOTE"
					fi
					getlist=`echo "$tmplist" | tail -n +2`
				else
					getlist=`ls -1 "$DATASET_REMOTE" | $SORT | head -n "$GET_NEW"`
				fi
			else
				getlist=`ls -1 "$DATASET_REMOTE" | $SORT | head -n "$GET_NEW"`
			fi
		else
			getlist=''
		fi
	
	else
		deletelist=`echo "$usedlist" | head --lines=-$KEEP_OLD`
		keeplist=`  echo "$usedlist" | tail -n $KEEP_OLD`
		
		last=`echo "$usedlist" | tail -n 1 | xargs echo`
		last=`basename "$last"` #*after* this entry the entries start that we want. we know that -z "last" cause we checked $usedlist
		tmplist=`ls -1 "$DATASET_REMOTE" | $SORT | grep -A $GET_NEW "$last"`
		if [ $? -gt 0 ]
		then
			echo_debug "command: ls -1 $DATASET_REMOTE | $SORT | grep -A $GET_NEW $last"
			echo_die "Could not find last known element ( from used files ) $last in repository $DATASET_REMOTE"
		fi
		getlist=`echo "$tmplist" | tail -n +2`
	
	fi
	
	deletefiles "$deletelist"
	keepfiles   "$keeplist"	#NOTE: there might be more files kept actually.. just files that are also in the dir...
	getfiles    "$getlist"

}

wrap_rsync ()
{
	if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ]
	then
		echo_die 'internal error: insufficient parameters to rsync wrapper'
	fi
	if [ "$5" == '1' ]
	then
		ask_user 'delete extraneous files from dest dirs? (rsync --delete)' 1
		if [ "$user_response" == 'y' ]
		then
			rsync "$1" --delete --exclude="$2" "$3" "$4"
		else
			rsync "$1" --exclude="$2" "$3" "$4"
		fi
	else
		rsync "$1" --exclude="$2" "$3" "$4"
	fi
	result=$?
	if [ $result -eq 0 ]
	then
		echo "rsync success"
		if [ "$6" == '1' ]
		then
			ask_user 'locally delete files that we successfully sent to server?' 1
			#TODO: implement this
		fi
	else
		echo "rsync failed"
	fi
}


 #
 # CALLBACKS. CAN BE OVERWRITTEN IN DATASET-SPECIFIC .ddm FILES. there you can even ignore the $DATASET_TYPE and REPO_TYPE if you want
 #


precheckout ()
{
	true
}
docheckout ()
{
	if [ "$REPO_TYPE" == 'svn' ]
	then
		if [ $DATASET_TYPE == "buffer" ]
		then
			no_action "maybe we could copy (only) the remote directories as template hierachy"
		elif [ $DATASET_TYPE == "extension" ]
		then
			no_action
		elif [ $DATASET_TYPE == "direct" ]
		then
			no_action
		elif [ $DATASET_TYPE == "copy" ] || [ $DATASET_TYPE == "selection" ]
		then
			if [ $DATASET_TYPE == "selection" ]
			then
				echo_verbose "You are checking out a selection: i assume you will delete what you don't need afterwards?"
			fi
			svn checkout $DATASET_REMOTE $DATASET_LOCAL
			svn propset svn:ignore .ddm $DATASET_LOCAL #TODO: does this conflict with existing properties?
		fi
	elif [ "$REPO_TYPE" == 'vfs' ]
	then
		if [ $DATASET_TYPE == "copy" ] || [ $DATASET_TYPE == "selection" ]
		then
			if [ $DATASET_TYPE == "selection" ]
			then
				echo_verbose "You are checking out a selection: i assume you will delete what you don't need afterwards?"
			fi
			wrap_rsync -avu '**.ddm' "$DATASET_REMOTE/" "$DATASET_LOCAL"	
		elif [ $DATASET_TYPE == "direct" ]
		then
			no_action "TODO: check for mountpoints, maybe parents and try to mount"
		else
			no_action
		fi
	fi
}
postcheckout ()
{
	true
}			

precommit ()
{
	true
}
docommit ()
{
	if [ "$REPO_TYPE" == 'svn' ]
	then
		svn commit $DATASET_LOCAL -m $MSG
	elif [ "$REPO_TYPE" == 'vfs' ]
	then
		if [ $DATASET_TYPE == "copy" ]
		then
			wrap_rsync -avu '**.ddm' "$DATASET_LOCAL/" "$DATASET_REMOTE" 1 
		elif [ $DATASET_TYPE == "buffer" ]
		then
			wrap_rsync -avu '**.ddm' "$DATASET_LOCAL/" "$DATASET_REMOTE" 0 1
		elif [ $DATASET_TYPE == "selection" ]
		then
			no_action "Maybe the user made changes to the small subset of data he has and wants to commit those..
			          gonna be hard to implement something like that..."
		elif [ $DATASET_TYPE == "extension" ]
		then
			no_action "Since this is an extension, i woulnd't know where to send data to..."
		elif [ $DATASET_TYPE == "direct" ]
		then
			no_action "Maybe we could umount? ( if it's a direct mount) and ask to umount if the parent is a mountpoint"
		fi
	fi 

}
postcommit ()
{
	true
}

preupdate ()
{
	true
}
doupdate ()
{
	if [ "$REPO_TYPE" == 'svn' ]
	then
		svn update $DATASET_LOCAL
	elif [ "$REPO_TYPE" == 'vfs' ]
	then
		rsync -avu --exclude='**.ddm' $DATASET_REMOTE/ $DATASET_LOCAL
	fi 


}
postupdate ()
{
	true
}	



 #
 # START THE ACTUAL PROCESSING
 #

#VARS OVERRIDABLE BY USER

SVN_BASE=''
SVN_PREFIX=''
SVN_SUFFIX=''
VFS_BASE=''
VFS_PREFIX=''
VFS_SUFFIX=''

DEFAULT_REPO_TYPE='vfs'
ALLOWED_REPO_TYPES='vfs svn'
ALLOWED_DATASET_TYPES='buffer copy direct extension selection'
DEFAULT_ACTION='update' #not used
ALLOWED_ACTIONS='checkout commit update'
IGNORE_DATASET_REMOTE_SVN=0

# look for a ddmrc to load according to the XDG basedir spec
for config_dir in `echo ${XDG_CONFIG_HOME:-$HOME/.config}:${XDG_CONFIG_DIRS:-/etc/xdg} | sed 's/:/\t/g'`
do
	config_dir=`echo $config_dir | sed 's#/$##'`
	if [ -r $config_dir/ddm/ddmrc ]
	then
		source $config_dir/ddm/ddmrc
		ddmrc_included='y'
		if [ $? -gt 0 ]
		then
			echo_die "There is a problem with your $config_dir/ddm/ddmrc . probably incorrect syntax"
		else
			echo_verbose_buffer="$echo_verbose_buffer Successfully included ${XDG_CONFIG_HOME:-$HOME/.config}/ddm/ddmrc\n"
		fi
		break
	fi
done
if [ -z "$ddmrc_included" ]
then
	echo_verbose_buffer="$echo_verbose_buffer No ddmrc included.  If you want to override some values, create a ${XDG_CONFIG_HOME:-$HOME/.config}/ddm/ddmrc\n"
fi

#VARS NOT OVERRIDABLE BY USER

PWD=`pwd`

XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
XDG_CONFIG_DIRS=${XDG_CONFIG_DIRS:-/etc/xdg}
XDG_DATA_HOME=${XDG_DATA_HOME:-$HOME/.local/share}
XDG_DATA_DIRS=${XDG_DATA_DIRS:-'/usr/local/share/:/usr/share/'}
XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}


DEFAULT_DATASET_TYPE='copy' # i dont think this should be changed by the user
ACTION_HELPSTRING="(one of: $ALLOWED_ACTIONS)"
DATASET_HELPSTRING="(pointer to/name of directory, default is \$PWD ($PWD))"
DATASET_TYPE_HELPSTRING="(one of: $ALLOWED_DATASET_TYPES, default is $DEFAULT_DATASET_TYPE)  Only used for checkouts"
REPO_TYPE_HELPSTRING="(one of: $ALLOWED_REPO_TYPES, default is $DEFAULT_REPO_TYPE)"
MESSAGE_HELPSTRING="(used for commits in svn, ignored otherwise)"
	
check_is_in "$DEFAULT_REPO_TYPE" "$ALLOWED_REPO_TYPES" 'repo type'


#ACTION=$DEFAULT_ACTION #Do not automatically set action. we want the user to explicitly pass -a <action> to prevent lots of stuff from happening by just executing ddm without args
DATASET_DIR_NAME_REL=''
DATASET_TYPE=$DEFAULT_DATASET_TYPE
REPO_TYPE=$DEFAULT_REPO_TYPE
MSG=''

while getopts “:a:d:t:r:m:vh” OPTION
do
	case $OPTION in
	a)
		if [ -z "$OPTARG" ]
		then
			echo_die "To use -a, specify an action as argument.  $ACTION_HELPSTRING"
		fi
		check_is_in "$OPTARG" "$ALLOWED_ACTIONS" action
		ACTION=$OPTARG
		;;
	d)
		if [ -z "$OPTARG" ]
		then
			echo_die "To use -d, specify a dataset as argument.  $DATASET_HELPSTRING"
		fi
		DATASET_DIR_NAME_REL=$OPTARG
		;;
	t)
		if [ -z "$OPTARG" ]
		then
			echo_die "To use -t, specify a dataset-type as argument.  $DATASET_TYPE_HELPSTRING"
		fi
		check_is_in "$OPTARG" "$ALLOWED_DATASET_TYPES" 'dataset type'
		DATASET_TYPE=$OPTARG
		;;
	r)
		if [ -z "$OPTARG" ]
		then
			echo_die "To use -r, specify a repo-type as argument.  $REPO_TYPE_HELPSTRING"
		fi
		check_is_in "$OPTARG" "$ALLOWED_REPO_TYPES" 'repo type'
		REPO_TYPE=$OPTARG
		;;
	m)
		if [ -z "$OPTARG" ]
		then
			echo_die "To use -m, specify a message as argument.  $MESSAGE_HELPSTRING"
		fi
		MSG=$OPTARG
		;;
	v)
		VERBOSE=1
		;;
	h)
		usage
		exit 0
		;;
	?)
		usage
		exit 1
		;;
	esac
done

#We now know if we want verbose or not, so we can flush pending output from before we parsed the arguments
echo_verbose $echo_verbose_buffer

# CHECK NEEDED OPTIONS

if [ -z "$ACTION" ]
then
	echo_die "You must specify an action with -a <action>.  $ACTION_HELPSTRING"
fi

set_dataset_info

# override some stuff in the .ddm script in the dataset

if [ -r $DATASET_LOCAL/.ddm ]
then
	source $DATASET_LOCAL/.ddm
	if [ $? -ne 0 ]
	then
		echo_die "Error: invalid $DATASET_LOCAL/.ddm"
	else
		echo_verbose "Included $DATASET_LOCAL/.ddm"
	fi
fi

check_remote_path "$DATASET_REMOTE" "$REPO_TYPE"

if [ "$ACTION" != checkout ]
then
	check_local_path "$DATASET_LOCAL" "$REPO_TYPE"
else
	check_writable_dir `dirname "$DATASET_LOCAL"` "parent dir for $REPO_TYPE dataset"
fi	

#if nothing else, We assume it is a dataset of type copy. cheesy way to catch typo's too...
if [ "$DATASET_TYPE" != buffer ] && [ "$DATASET_TYPE" != direct ] && [ "$DATASET_TYPE" != extension ] && [ "$DATASET_TYPE" != selection ]
then
	if [ -n "$DATASET_TYPE" ] && [ "$DATASET_TYPE" != $DEFAULT_DATASET_TYPE ]
	then
		echo "Unknown dataset type $DATASET_TYPE. defaulting to $DEFAULT_DATASET_TYPE"
	fi
	DATASET_TYPE=$DEFAULT_DATASET_TYPE
fi


# load ddm plugins according to the XDG basedir spec
for data_dir in `echo ${XDG_DATA_HOME}:${XDG_DATA_DIRS} | sed 's/:/\t/g'`
do
	data_dir=`echo $data_dir | sed 's#/$##'`
	if [ -r $data_dir/ddm/plugins ]
	then
		for plugin in $data_dir/ddm/plugins/*.sh
		do
			echo_verbose "Plugin   $plugin loading..."
			source "$plugin"
			if [ $? -gt 0 ]
			then
				echo "Warning: $plugin loading failed"
			else
				echo_verbose "Plugin   $plugin loaded"
			fi
		done
	fi
done

echo_verbose "action $ACTION on dataset name $DATASET_NAME type $DATASET_TYPE"

pre$ACTION
do$ACTION
post$ACTION

echo_verbose "finished"
