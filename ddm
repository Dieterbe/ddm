#!/bin/bash

VERSION='0.4b'

# DDM
# See included documentation

# Written by Dieter Plaetinck
# http://dieter.plaetinck.be
# http://github.com/Dieterbe/ddm
# This code is licensed under GPL v3. See http://www.gnu.org/licenses/gpl-3.0.txt

# basedir spec notes
# If, when attempting to write a file, the destination dir not exist try to create as 0700. If the exists dont change perms
# this means we should bail out and show error if write fails
 
# When we cannot open/read a file we need, then the processing of the file should be skipped.
#If due to this a required file could not be found at all, the application may chose to present an error message to the user. 


 
 #
 # SOME MISC FUNCTIONS
 #


usage()
{
cat << EOF
This is ddm $VERSION
usage: `basename $0` -a <action> [more options]
       `basename $0` -h

OPTIONS:
   -a <action>         Action         $ACTION_HELPSTRING
   -d <dataset-name>   Dataset name   $DATASET_NAME_HELPSTRING
   -t <dataset-type>   Dataset type   $DATASET_TYPE_HELPSTRING
   -r <repo-type>      Repo type      $REPO_TYPE_HELPSTRING
   -m <message>        Message        $MESSAGE_HELPSTRING
   -v                  Verbose
   -h                  Show help      (this message)
EOF
}

ask_user ()
{
	# $1 : question to ask
	# $2 : 1 for yes/no question, just check if  $user_response='y' afterwards
	
	user_response= # this variable will be read by the caller.

	[ -n "$1" ] && echo_die "ask_user called without question to ask" 100
	
	if [ "$2" == '1' ]
	then
		echo "$1 (y/n)"
	else
		echo "$1"
	fi
		
	read user_response
	user_response=`tr "[:upper:]" "[:lower:]" <<< $user_response`
	
	[ "$2" == '1' ] && [ "$user_response" == 'y' -o "$user_response" == 'yes' ] && user_response='y'
}

echo_verbose ()
{
	if [ -n "$VERBOSE" ]
	then
		#TODO: emits a newline too many when there is a newline at the end of "$@" such as is the case when echo_verbose_buffer is echo'd. to be fixed someday
		#echo -e "${@/\n\$/}"
		echo -e "$@"
	fi
}

echo_debug ()
{
	if [ "$DEBUG" == "1" ] #export this variable or set it through ddmrc.
	then
		echo "DEBUG: $@"
	fi
	
	return 0
}

echo_die ()
{
	echo "$1" >&2
	[ -n "$2" ] && exit $2
	echo "No exit code set when calling echo_die"
	exit 100
}

check_is_in()
{
	test=${1:-unknown}
	allowed=${2:-unknown}
	type=${3:-unknown}
	exitcode=${4:-100}
	
	found=0
	
	for all in $allowed
	do
		if [ $all == $test ]
		then
			found=1
		fi
	done
	
	if [ $found -eq 0 ]
	then
		echo_die "$test is not an allowed/known $type (allowed: $allowed)" $exitcode
	fi
}

check_writable_dir ()
{

	[ -z "$1" -o -z "$2" ] && echo_debug "No path or type given when calling check_writable_dir" && exit 100

	path="$1"
	type="$2"
	exitcode=${3:-100}
	
	if [ ! -d "$path" ]
	then
		echo_die "$2 $path does not exist or is not a directory" $exitcode
	elif [ ! -r "$path" ]
	then
		echo_die "$2 $path is an existing directory, but is not readable" $exitcode
	elif [ ! -x "$path" ] # not sure if this is really needed...
	then
		echo_die "$2 $path is a readable directory, but not executable" $exitcode
	fi
}

check_repo_path ()
{
	[ -z "$1" -o -z "$2" ] && echo_debug "no path or repotype given when calling check_repo_path" && exit 100
	path=$1
	repotype=$2
	exitcode=3
	
	if [ "$repotype" == 'svn' ]
	then
		if [ "$IGNORE_DATASET_REMOTE_SVN" -eq 0 ]
		then
			output=`svn info $path 2>&1`
			if [ $? -gt 0 ]
			then
				echo "Something appears to be wrong with the $repotype repo $path :"
				echo_die "$output" $exitcode
			fi
		fi
	elif [ "$repotype" == 'vfs' ]
	then
		check_writable_dir "$path" "$repotype repo" $exitcode
	fi
}

check_dataset_path ()
{
	[ -z "$1" -o -z "$2" ] && echo_debug "no path or repotype given when calling check_dataset_path" && exit 100
	path=$1
	repotype=$2
	exitcode=2
	
	if [ "$repotype" == 'svn' ]
	then
		output=`svn info $path 2>&1`
		if [ $? -gt 0 ]
		then
			echo "Something appears to be wrong with the $repotype dataset $path :"
			echo_die "$output" $exitcode
		fi

		if [ "$IGNORE_DATASET_REMOTE_SVN" -eq 0 ]
		then
			remote=`echo "$output" | grep 'URL: ' | awk '{print $2}'`
			if [ "$remote" != "$DATASET_REMOTE_FULL" ]
			then
				echo "Mismatch between remote svn paths:"
				echo ".ddm : $DATASET_REMOTE_FULL"
				echo "local svn info : $remote"
			fi
		fi
	elif [ "$repotype" == 'vfs' ]
	then
		check_writable_dir "$path" "$repotype dataset" $exitcode
	fi
}


set_dataset_info()
{
	# here we set all the variables, based on what DATASET_LOCAL_REL (given by user) & PWD are
	# DATASET_LOCAL_REL             # identifier to dataset, taken against pwd ( could be '.','..', nothing at all, dirname, full path, ..) 

	# DATASET_REMOTE_FULL=''        # full path to dataset remotely (or locally if network mount)
	# DATASET_LOCAL_FULL=''         # full path to dataset locally (including type suffix if any)
	# DATASET_LOCAL_PARENT_FULL=''  # the path of the parent directory of dataset ( aka dirname )
	# DATASET_LOCAL_BASE=''         # like $DATASET_LOCAL_FULL but no path ( aka basename) 
	# DATASET_LOCAL_NAME=''         # like $DATASET_LOCAL_BASE but no type suffix
	# DATASET_TYPE=''               # buffer,copy,extensions etc

	#remove trailing /, if any
	DATASET_LOCAL_REL=`sed 's#/$##' <<< $DATASET_LOCAL_REL`

	if [ -z "$DATASET_LOCAL_REL" ] || [ "$DATASET_LOCAL_REL" == '.' ]
	then
		DATASET_LOCAL_FULL=$PWD
	elif [ "$DATASET_LOCAL_REL" == '..' ]
	then
		DATASET_LOCAL_FULL=`dirname $PWD`
	else
		#prepend path to make absolute, if needed
		if grep '^/' <<< $DATASET_LOCAL_REL > /dev/null
		then
			DATASET_LOCAL_FULL=$DATASET_LOCAL_REL
		else
			[ $PWD == '/' ] && PWD=''
			DATASET_LOCAL_FULL=$PWD/$DATASET_LOCAL_REL
		fi
	fi

	DATASET_LOCAL_BASE=`basename $DATASET_LOCAL_FULL`
	DATASET_LOCAL_PARENT_FULL=`    dirname $DATASET_LOCAL_FULL`
	DATASET_LOCAL_NAME=`    sed 's/-[^-]*$//' <<< $DATASET_LOCAL_BASE` #TODO: this is a bug. the directory can-be-named-like-this. we must check that the last part is a valid dataset type.
	[ $ACTION != checkout ] && DATASET_TYPE=`   sed 's/.*-//' <<< $DATASET_LOCAL_BASE ` #TODO: see above
	[ $ACTION != checkout ] && [ "$DATASET_TYPE" == "$DATASET_LOCAL_BASE" ] && DATASET_TYPE=$DEFAULT_DATASET_TYPE #assign default dataset type if not derived from basename
	[ "$REPO_TYPE" == 'svn' ] && DATASET_REMOTE_FULL=`echo $SVN_BASE | sed 's#/$##'`"/${SVN_PREFIX}${DATASET_LOCAL_NAME}${SVN_SUFFIX}"
	[ "$REPO_TYPE" == 'vfs' ] && DATASET_REMOTE_FULL=`echo $VFS_BASE | sed 's#/$##'`"/${VFS_PREFIX}${DATASET_LOCAL_NAME}${VFS_SUFFIX}"
}


 #
 # WORKER HELPER FUNCTIONS. TO BE USED BY WORKER FUNCTIONS
 #
 
# delete files from dataset
deletefiles ()
{
	deletelist="$1"
	deletelistsize=`grep -cv '^$' <<< "$deletelist"`
	echo_debug "deletelist (size : $deletelistsize) : $deletelist"

	echo_verbose "Deleting old files ... ($deletelistsize items)."
	IFS=$'\n'
	for file in $deletelist
	do
		file=`echo $file | sed 's/ $//'`
		if [ "$file" != '..' ] && [ "$file" != '.' ]
		then
                        file=`echo $file | xargs echo` #remove escape characters.. dont know if this is the best way
			#file=`basename $file` #deprecated : lets make it the responsability of the caller to decide what he wants to delete
                        if [ `pwd` != "$DATASET_LOCAL_FULL" ]
                        then
                        	file="$DATASET_LOCAL_FULL/$file"
                        fi
                        
			echo_verbose -n " * $file... "

                        if [ -f "$file" ]
                        then
                                echo_verbose -n "found . removing... "
                                rm "$file"
				if [ $? -eq 0 ]
				then
					echo_verbose "success"
				else
					echo_verbose "failed"
                        	fi
                        else
                                echo_verbose "not found"
                        fi
                fi
	done
}	

keepfiles ()
{
	keeplist="$1"
	keeplistsize=`grep -cv '^$' <<< "$keeplist"`
	echo_debug "keeplist (size : $keeplistsize) : $keeplist"
	
	echo_verbose "Keeping these files... ($keeplistsize items)."
        IFS=$'\n'
        for file in $keeplist
        do
        	file=`echo "$file" | xargs echo` # -0 fixes quotes but keeps escapes :(
        	file=`basename $file`
		if [ `pwd` != "$DATASET_LOCAL_FULL" ]
		then
			file="$DATASET_LOCAL_FULL/$file"
		fi

        	echo_verbose " * $file"
        done
}

getfiles () #copy files from repo into dataset
{
	getlist="$1"
	getlistsize=`grep -cv '^$' <<< "$getlist"`
	echo_debug "getlist (size :$getlistsize) : $getlist"
	
	echo_verbose "Copying new files  ... ($getlistsize items)."
	IFS=$'\n'
	for file in $getlist
	do
		file_displ=$file
		if [ `pwd` != "$DATASET_LOCAL_FULL" ]
		then
			file_displ="$DATASET_LOCAL_FULL/$file_displ"
		fi

		echo_verbose -n " * $file_displ... "
		#cp "$DATASET_REMOTE_FULL/$file" "$DATASET_LOCAL_FULL/"
		dirname=`dirname "$file"`
		if [ $dirname != '.' ]
		then
			mkdir -p $DATASET_LOCAL_FULL/$dirname
			if [ $? -gt 0 ]
			then
				echo_verbose "failed (could not make directory $dirname)"
				break
			fi
			rsync -avuq --exclude='**.ddm' "$DATASET_REMOTE_FULL/$file" "$DATASET_LOCAL_FULL/$dirname/"
		else
			rsync -avuq --exclude='**.ddm' "$DATASET_REMOTE_FULL/$file" "$DATASET_LOCAL_FULL/"
		fi
		if [ $? -eq 0 ]
		then
			echo_verbose "success"
		else
			echo_verbose "failed (could not rsync)"
		fi
	done
		       
}


 #
 # WORKER FUNCTIONS TO BE USED BY THE CALLBACKS
 #
 
no_action ()
{
	echo "No action taken.  This is either not implemented yet or just wouldn't make much sense."
	echo "You can 1) implement what you want in $DATASET_LOCAL_FULL/.ddm"
	echo "        2) file a feature request if this seems reasonable (or send a patch)"
	if [ -n "$1" ]
	then
		echo "Note from the author: $1"
	fi
}

wrap_rsync ()
{
	if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ]
	then
		echo_die 'internal error: insufficient parameters to rsync wrapper' 100
	fi
	if [ "$5" == '1' ]
	then
		ask_user 'delete extraneous files from dest dirs? (rsync --delete)' 1
		if [ "$user_response" == 'y' ]
		then
			rsync "$1" --delete --exclude="$2" "$3" "$4"
		else
			rsync "$1" --exclude="$2" "$3" "$4"
		fi
	else
		rsync "$1" --exclude="$2" "$3" "$4"
	fi
	result=$?
	if [ $result -eq 0 ]
	then
		echo "rsync success"
		if [ "$6" == '1' ]
		then
			ask_user 'locally delete files that we successfully sent to server?' 1
			#TODO: implement this
		fi
	else
		echo "rsync failed"
	fi
}


 #
 # CALLBACKS. CAN BE OVERWRITTEN IN DATASET-SPECIFIC .ddm FILES. there you can even ignore the $DATASET_TYPE and REPO_TYPE if you want
 #

prebackup ()
{
	if [ $DATASET_TYPE == "selection" ]
	then
		true
	else
		precommit
	fi
}
dobackup ()
{
	if [ $DATASET_TYPE == "selection" ]
	then
		true
		#TODO: implement backup for selection
	else
		docommit
	fi
}
postbackup ()
{
	if [ $DATASET_TYPE == "selection" ]
	then
		true
	else
		postcommit
	fi
}

precheckout ()
{
	true
}
docheckout ()
{
	# all datatypes: blob buffer cache copy direct extension selection
	# not possible: blob, direct
	# defined for: copy selection
	if [ "$REPO_TYPE" == 'svn' ] && [ $DATASET_TYPE == "buffer" ]
	then
		no_action "maybe we could copy (only) the remote directories as template hierachy? Is this what you expected?"
	elif [ "$REPO_TYPE" == 'svn' ] && [ $DATASET_TYPE == "extension" ]
	then
		no_action "maybe we could copy (only) the remote directories as template hierachy? Is this what you expected?"
	elif [ "$REPO_TYPE" == 'svn' ] && [ $DATASET_TYPE == "direct" ]
	then
			no_action
	elif [ "$REPO_TYPE" == 'svn' ] && [ $DATASET_TYPE == "selection" ]
	then
		echo_verbose "You are checking out a selection: i assume you will delete what you don't need afterwards?"
		svn checkout $DATASET_REMOTE_FULL $DATASET_LOCAL_FULL
		props=`svn propget svn:ignore $DATASET_LOCAL_FULL`
		svn propset svn:ignore "$props
.ddm" $DATASET_LOCAL_FULL #TODO: clean this up
	elif [ "$REPO_TYPE" == 'svn' ] && [ $DATASET_TYPE == "copy" ]
	then
		svn checkout $DATASET_REMOTE_FULL $DATASET_LOCAL_FULL
		props=`svn propget svn:ignore $DATASET_LOCAL_FULL`
		svn propset svn:ignore "$props
.ddm" $DATASET_LOCAL_FULL #TODO: clean this up

	elif [ "$REPO_TYPE" == 'vfs' ] && [ $DATASET_TYPE == "selection" ]
	then
		echo_verbose "You are checking out a selection: either you delete what you don't need afterwards, or you override this function to do what you want"
		wrap_rsync -avu '**.ddm' "$DATASET_REMOTE_FULL/" "$DATASET_LOCAL_FULL"	
	elif [ "$REPO_TYPE" == 'vfs' ] && [ $DATASET_TYPE == "copy" ] 
	then
		wrap_rsync -avu '**.ddm' "$DATASET_REMOTE_FULL/" "$DATASET_LOCAL_FULL" 
	elif [ $DATASET_TYPE == "direct" ]
	then
		no_action "TODO: check for mountpoints, maybe parents and try to mount"
	else
		no_action
	fi
}
postcheckout ()
{
	true
}			

precommit ()
{
	true
}
docommit ()
{
	if [ "$REPO_TYPE" == 'svn' ]
	then
		svn commit $DATASET_LOCAL_FULL -m $MSG
	elif [ "$REPO_TYPE" == 'vfs' ]
	then
		if [ $DATASET_TYPE == "copy" ]
		then
			wrap_rsync -avu '**.ddm' "$DATASET_LOCAL_FULL/" "$DATASET_REMOTE_FULL" 1 
		elif [ $DATASET_TYPE == "buffer" ]
		then
			wrap_rsync -avu '**.ddm' "$DATASET_LOCAL_FULL/" "$DATASET_REMOTE_FULL" 0 1
		elif [ $DATASET_TYPE == "selection" ]
		then
			no_action "Maybe the user made changes to the small subset of data he has and wants to commit those..
			          gonna be hard to implement something like that..."
		elif [ $DATASET_TYPE == "extension" ]
		then
			no_action "Since this is an extension, i woulnd't know where to send data to..."
		elif [ $DATASET_TYPE == "direct" ]
		then
			no_action "Maybe we could umount? ( if it's a direct mount) and ask to umount if the parent is a mountpoint"
		fi
	fi 

}
postcommit ()
{
	true
}

preupdate ()
{
	true
}
doupdate ()
{
	if [ "$REPO_TYPE" == 'svn' ]
	then
		svn update $DATASET_LOCAL_FULL
	elif [ "$REPO_TYPE" == 'vfs' ]
	then
		rsync -avu --exclude='**.ddm' $DATASET_REMOTE_FULL/ $DATASET_LOCAL_FULL
	fi 


}
postupdate ()
{
	true
}	



 #
 # START THE ACTUAL PROCESSING
 #

# load ddm plugins according to the XDG basedir spec
PWD_BEFORE=`pwd`
for data_dir in `echo ${XDG_DATA_HOME:-$HOME/.local/share}:${XDG_DATA_DIRS:-'/usr/local/share/:/usr/share/'} | sed 's/:/\t/g'`
do
	data_dir=`echo $data_dir | sed 's#/$##'`
	if [ -r $data_dir/ddm/plugins ]
	then
		for plugin in $data_dir/ddm/plugins/*.sh
		do
			echo_verbose_buffer="${echo_verbose_buffer}Plugin   $plugin loading...\n"
			source "$plugin"
			if [ $? -gt 0 ]
			then
				echo "Warning: $plugin loading failed"
			else
				echo_verbose_buffer="${echo_verbose_buffer}Plugin   $plugin loaded\n"
			fi
			cd $PWD_BEFORE #undo any changes to PWD the plugin might have done
		done
	fi
done

#VARS OVERRIDABLE BY USER

SVN_BASE=''
SVN_PREFIX=''
SVN_SUFFIX=''
VFS_BASE=''
VFS_PREFIX=''
VFS_SUFFIX=''

DEFAULT_REPO_TYPE='vfs'
ALLOWED_REPO_TYPES='vfs svn'
ALLOWED_DATASET_TYPES='blob buffer cache copy direct extension selection'
ALLOWED_ACTIONS='backup checkout commit flush restore update'
IGNORE_DATASET_REMOTE_SVN=0

# look for a ddmrc to load according to the XDG basedir spec

for config_dir in `echo ${XDG_CONFIG_HOME:-$HOME/.config}:${XDG_CONFIG_DIRS:-/etc/xdg} | sed 's/:/\t/g'`
do
	config_dir=`sed 's#/$##' <<< $config_dir`
	if [ -r $config_dir/ddm/ddmrc ]
	then
		source $config_dir/ddm/ddmrc
		ddmrc_included='y'
		if [ $? -gt 0 ]
		then
			echo_die "There is a problem with your $config_dir/ddm/ddmrc . probably incorrect syntax" 1
		else
			echo_verbose_buffer="${echo_verbose_buffer}Successfully included $config_dir/ddm/ddmrc\n"
		fi
		break
	fi
done
if [ -z "$ddmrc_included" ]
then
	echo_verbose_buffer="${echo_verbose_buffer}Something failed while including ddmrc.  If you want to override some values, create a ${XDG_CONFIG_HOME:-$HOME/.config}/ddm/ddmrc in valid bash\n"
fi

PWD_AFTER=`pwd`
[ "$PWD_AFTER" != "$PWD_BEFORE" ] && echo_die "Please don't cd in your ddmrc script.  PWD must remain the same!" 1


#VARS NOT OVERRIDABLE BY USER
PWD=$PWD_BEFORE

DEFAULT_DATASET_TYPE='copy' # i dont think this should be changed by the user
ACTION_HELPSTRING="(one of: $ALLOWED_ACTIONS)"
DATASET_NAME_HELPSTRING="(pointer to/name of directory, default is \$PWD ($PWD))"
DATASET_TYPE_HELPSTRING="(one of: $ALLOWED_DATASET_TYPES, default is $DEFAULT_DATASET_TYPE). Usually only needed explicitly for checkouts"
REPO_TYPE_HELPSTRING="(one of: $ALLOWED_REPO_TYPES, default is $DEFAULT_REPO_TYPE)"
MESSAGE_HELPSTRING="(usually only used for commits in svn)"
	
check_is_in "$DEFAULT_REPO_TYPE" "$ALLOWED_REPO_TYPES" 'repo type' 3


DATASET_LOCAL_REL=''
DATASET_TYPE=$DEFAULT_DATASET_TYPE
REPO_TYPE=$DEFAULT_REPO_TYPE
MSG=''

while getopts “:a:d:t:r:m:vh” OPTION
do
	case $OPTION in
	a)
		if [ -z "$OPTARG" ]
		then
			echo_die "To use -a, specify an action as argument.  $ACTION_HELPSTRING" 5
		fi
		#check_is_in "$OPTARG" "$ALLOWED_ACTIONS" action 4 #TODO : will be allow custom actions or not? probably not.. mss user ALLOWED_ACTIONS laten definen in ddmrc
		ACTION=$OPTARG
		;;
	d)
		if [ -z "$OPTARG" ]
		then
			echo_die "To use -d, specify a dataset as argument.  $DATASET_NAME_HELPSTRING" 5
		fi
		DATASET_LOCAL_REL=$OPTARG
		;;
	t)
		if [ -z "$OPTARG" ]
		then
			echo_die "To use -t, specify a dataset-type as argument.  $DATASET_TYPE_HELPSTRING" 5
		fi
		check_is_in "$OPTARG" "$ALLOWED_DATASET_TYPES" 'dataset type' 2
		DATASET_TYPE=$OPTARG
		;;
	r)
		if [ -z "$OPTARG" ]
		then
			echo_die "To use -r, specify a repo-type as argument.  $REPO_TYPE_HELPSTRING" 5
		fi
		check_is_in "$OPTARG" "$ALLOWED_REPO_TYPES" 'repo type' 3
		REPO_TYPE=$OPTARG
		;;
	m)
		if [ -z "$OPTARG" ]
		then
			echo_die "To use -m, specify a message as argument.  $MESSAGE_HELPSTRING" 5
		fi
		MSG=$OPTARG
		;;
	v)
		VERBOSE=1
		;;
	h)
		usage
		exit 0
		;;
	?)
		usage
		exit 5
		;;
	esac
done

#We now know if we want verbose or not, so we can flush pending output from before we parsed the arguments
echo_verbose $echo_verbose_buffer

# CHECK NEEDED OPTIONS
# If no action is specified, calling ddm is useless.
if [ -z "$ACTION" ]
then
       echo_die "You must specify an action with -a <action>.  $ACTION_NAME_HELPSTRING" 4
fi
# Check if the dataset is defined for the repository type.
if [ $REPO_TYPE == 'svn' ] && [ $DATASET_TYPE == 'blob' -o $DATASET_TYPE == 'direct' ]
then
	echo "A $DATASET_TYPE dataset for a svn repository? That wouldn't make much sense now would it?" 2
fi


set_dataset_info

# override some stuff in the .ddm script in the dataset

if [ -r $DATASET_LOCAL_FULL/.ddm ]
then
	source $DATASET_LOCAL_FULL/.ddm
	if [ $? -ne 0 ]
	then
		echo_die "Error: invalid $DATASET_LOCAL_FULL/.ddm" 2
	else
		echo_verbose "Included $DATASET_LOCAL_FULL/.ddm" 
	fi
fi

PWD_AFTER=`pwd`
[ "$PWD_AFTER" != "$PWD" ] && echo_die "Please don't cd in your .ddm scripts.  PWD must remain the same!" 2   
        

check_repo_path "$DATASET_REMOTE_FULL" "repository $REPO_TYPE"

if [ "$ACTION" != checkout ]
then
	check_dataset_path "$DATASET_LOCAL_FULL" "repository $REPO_TYPE"
else
	check_writable_dir `dirname "$DATASET_LOCAL_FULL"` "parent dir for $REPO_TYPE dataset" 2
fi	

echo_verbose "action $ACTION on dataset name $DATASET_LOCAL_NAME type $DATASET_TYPE"

pre$ACTION
do$ACTION
post$ACTION

echo_verbose "finished"
